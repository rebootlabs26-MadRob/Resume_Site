#!/usr/bin/env python3
# ReBootLab-DiagToolC.py
# Final: Flat Dark Mode, slim right column, subtle purple in POST tile only.
# Requirements: python3, psutil
# Install: pip3 install psutil

import os
import sys
import time
import json
import psutil
import socket
import platform
import threading
import datetime
import subprocess
from functools import partial
import tkinter as tk
from tkinter import ttk, messagebox, filedialog

# ---------------- Config ----------------
POLL_INTERVAL = 2.0  # seconds (Pi3 safe)
APP_TITLE = "ReBoot Lab - DiagTool C"
REPORTS_DIR = "diag_reports"
os.makedirs(REPORTS_DIR, exist_ok=True)

# Colors (Flat Dark Mode + subtle purple limited to POST tile)
BG = "#000000"             # main background
CARD_BG = "#0d0d0d"        # card background
CARD_BORDER = "#1f1f1f"    # card border
ACCENT_GREEN = "#39ff14"   # main accent
ACCENT_BLUE = "#0044ff"    # small secondary accent (very subtle)
ACCENT_PURPLE = "#8b3cff"  # used only in POST tile headings / small accents
ERROR_RED = "#ff0033"      # errors
TEXT_MAIN = "#e6eef6"      # main text
TEXT_SUB = "#bfcbd6"       # subtext

FONT_TITLE = ("Segoe UI", 12, "bold")
FONT_TEXT  = ("Consolas", 11)

# ---------------- Logging helper (minimal) ----------------
def log(msg):
    try:
        ts = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        print(f"[{ts}] {msg}")
    except:
        pass

# ---------------- Safe shell command ----------------
def safe_cmd(cmd, timeout=4):
    try:
        out = subprocess.check_output(cmd, shell=True, stderr=subprocess.DEVNULL, timeout=timeout)
        return out.decode(errors="ignore").strip()
    except Exception:
        return ""

# ---------------- Readers ----------------
def human_bytes(n):
    try:
        n = float(n)
    except Exception:
        return "N/A"
    for unit in ['B','KB','MB','GB','TB']:
        if abs(n) < 1024.0:
            return f"{n:3.1f} {unit}"
        n /= 1024.0
    return f"{n:.1f} PB"

def get_system_info():
    try:
        s = {}
        s['os'] = platform.system() + " " + platform.release()
        s['hostname'] = socket.gethostname()
        s['kernel'] = platform.version()
        s['uptime'] = _uptime()
        vm = psutil.virtual_memory()
        s['ram_total'] = f"{round(vm.total / (1024**3), 2)} GB"
        s['ram_used'] = f"{round(vm.used / (1024**3), 2)} GB ({vm.percent}%)"
        return s
    except Exception:
        return {}

def _uptime():
    try:
        b = psutil.boot_time()
        delta = datetime.datetime.now() - datetime.datetime.fromtimestamp(b)
        days = delta.days
        hrs = delta.seconds // 3600
        mins = (delta.seconds % 3600) // 60
        return f"{days}d {hrs}h {mins}m"
    except Exception:
        return "N/A"

def get_cpu_info():
    try:
        c = {}
        c['model'] = platform.processor() or safe_cmd("lscpu | grep 'Model name' -m1 | cut -d: -f2").strip() or "N/A"
        c['cores'] = psutil.cpu_count(logical=False) or "N/A"
        c['threads'] = psutil.cpu_count(logical=True) or "N/A"
        freq = psutil.cpu_freq()
        if freq:
            c['clock'] = f"{int(freq.current)} MHz"
            c['min_clock'] = f"{int(freq.min)} MHz"
            c['max_clock'] = f"{int(freq.max)} MHz"
        else:
            c['clock'] = "N/A"
            c['min_clock'] = "N/A"
            c['max_clock'] = "N/A"
        c['load'] = f"{psutil.cpu_percent(interval=None)} %"
        # temperature best-effort
        try:
            temps = psutil.sensors_temperatures()
            if temps:
                # pick first available sensor
                first = next(iter(temps.values()))
                if first:
                    c['temp_c'] = f"{round(first[0].current,1)} C"
                else:
                    c['temp_c'] = "N/A"
            else:
                c['temp_c'] = "N/A"
        except Exception:
            c['temp_c'] = "N/A"
        return c
    except Exception:
        return {}

def get_gpu_info():
    # best-effort: nvidia-smi or lspci fallback
    try:
        g = {}
        if shutil_which("nvidia-smi"):
            out = safe_cmd("nvidia-smi --query-gpu=name,memory.total,driver_version,temperature.gpu --format=csv,noheader,nounits")
            cols = [c.strip() for c in out.split(",")] if out else []
            g['model'] = cols[0] if len(cols) > 0 else "NVIDIA"
            g['vram'] = cols[1] + " MB" if len(cols) > 1 else "N/A"
            g['driver'] = cols[2] if len(cols) > 2 else "N/A"
            g['temp'] = cols[3] + " C" if len(cols) > 3 else "N/A"
        else:
            # lspci
            lp = safe_cmd("lspci -nn | grep -E 'VGA|3D' -m1")
            g['model'] = lp or "N/A"
            g['vram'] = "N/A"
            g['driver'] = "N/A"
            g['temp'] = "N/A"
        return g
    except Exception:
        return {}

def shutil_which(cmd):
    return shutil.which(cmd) is not None

import shutil  # used in get_gpu_info

def get_voltage_info():
    v = {}
    # Use sensors or vcgencmd where available
    if shutil_which("sensors"):
        out = safe_cmd("sensors")
        # quick regex-free parse for typical rails
        v['12v'] = _find_value_in(out, r'12V.*?([0-9]+\.[0-9]+)') or "N/A"
        v['5v']  = _find_value_in(out, r'5V.*?([0-9]+\.[0-9]+)') or "N/A"
        v['3v3'] = _find_value_in(out, r'3.3V.*?([0-9]+\.[0-9]+)') or "N/A"
    elif shutil_which("vcgencmd"):
        # raspberry pi option
        vcore = safe_cmd("vcgencmd measure_volts core")
        if vcore:
            # format like 'volt=1.2000V'
            m = _find_value_in(vcore, r'([0-9]+\.[0-9]+)')
            v['core'] = m + " V" if m else "N/A"
        else:
            v['core'] = "N/A"
        v.setdefault('12v', "N/A"); v.setdefault('5v', "N/A"); v.setdefault('3v3', "N/A")
    else:
        v['12v'] = "N/A"; v['5v'] = "N/A"; v['3v3'] = "N/A"
    return v

def _find_value_in(text, pattern):
    import re
    try:
        m = re.search(pattern, text, re.IGNORECASE)
        if m: return m.group(1)
    except Exception:
        pass
    return None

def get_network_info():
    n = {}
    try:
        addrs = psutil.net_if_addrs()
        stats = psutil.net_if_stats()
        ifaces = {}
        for name, addrl in addrs.items():
            # skip loopback
            if name.lower().startswith("lo"): continue
            entry = {"ips": [], "mac": "N/A", "isup": "N/A", "speed": "N/A"}
            for a in addrl:
                if getattr(a, "family", None) == socket.AF_INET:
                    entry["ips"].append(a.address)
                elif getattr(a, "family", None) == psutil.AF_LINK or getattr(a, "family", None) == getattr(psutil, "AF_LINK", None):
                    entry["mac"] = a.address
            st = stats.get(name)
            if st:
                entry["isup"] = st.isup
                entry["speed"] = f"{st.speed} Mbps" if st.speed else "N/A"
            ifaces[name] = entry
        n['ifaces'] = ifaces
        counters = psutil.net_io_counters()
        n['bytes_sent'] = human_bytes(counters.bytes_sent)
        n['bytes_recv'] = human_bytes(counters.bytes_recv)
    except Exception:
        pass
    return n

def get_storage_info():
    s = {}
    try:
        parts = psutil.disk_partitions(all=False)
        drives = []
        for p in parts:
            try:
                usage = psutil.disk_usage(p.mountpoint)
                drives.append({
                    "device": p.device,
                    "mountpoint": p.mountpoint,
                    "fstype": p.fstype,
                    "total": human_bytes(usage.total),
                    "used": human_bytes(usage.used),
                    "free": human_bytes(usage.free),
                    "percent": f"{usage.percent} %"
                })
            except Exception:
                drives.append({"device": p.device, "mountpoint": p.mountpoint, "fstype": p.fstype, "total": "N/A"})
        s['drives'] = drives
        # smartctl optional info
        if shutil_which("smartctl"):
            s['smart'] = []
            devs = safe_cmd("lsblk -ndo NAME,TYPE | awk '$2==\"disk\"{print $1}'").splitlines()
            for d in devs:
                dp = "/dev/" + d.strip()
                if dp.strip() == "/dev/": continue
                out = safe_cmd(f"sudo smartctl -H {dp}")
                if out:
                    ok = "PASSED" if "PASSED" in out else out.splitlines()[0]
                    s['smart'].append({"device": dp, "health": ok})
    except Exception:
        pass
    return s

def get_post_and_logs():
    p = {"latest": "N/A", "history": []}
    try:
        if platform.system() == "Linux":
            d = safe_cmd("dmesg --level=err,warn | tail -n 500")
            p['history'] = d.splitlines() if d else []
            p['latest'] = p['history'][0] if p['history'] else "N/A"
        elif platform.system() == "Windows":
            out = safe_cmd('wevtutil qe System /rd:true /f:text /c:200')
            p['history'] = out.splitlines() if out else []
            p['latest'] = p['history'][0] if p['history'] else "N/A"
    except Exception:
        pass
    return p

def scan_os_errors():
    errs = []
    try:
        if platform.system() == "Linux":
            out = safe_cmd("journalctl -p 3 -n 200 --no-pager") if shutil_which("journalctl") else safe_cmd("dmesg --level=err | tail -n 200")
            if out:
                for line in out.splitlines():
                    if line.strip():
                        errs.append(line.strip())
    except Exception:
        pass
    return errs

# ---------------- Poller Thread ----------------
shared = {
    "system": {}, "cpu": {}, "gpu": {}, "voltage": {}, "network": {}, "storage": {}, "post": {}, "errors": []
}
shared_lock = threading.Lock()
stop_event = threading.Event()

def poll_loop():
    while not stop_event.is_set():
        try:
            sysd = get_system_info()
            cpud = get_cpu_info()
            gpud = get_gpu_info()
            volt = get_voltage_info()
            netd = get_network_info()
            stor = get_storage_info()
            post = get_post_and_logs()
            errs = scan_os_errors()
            with shared_lock:
                shared['system'] = sysd
                shared['cpu'] = cpud
                shared['gpu'] = gpud
                shared['voltage'] = volt
                shared['network'] = netd
                shared['storage'] = stor
                shared['post'] = post
                shared['errors'] = errs
                shared['last_update'] = datetime.datetime.now().isoformat()
        except Exception:
            pass
        # break poll interval into short sleeps to allow stop_event to be responsive
        for _ in range(int(POLL_INTERVAL * 10)):
            if stop_event.is_set():
                break
            time.sleep(0.1)

# ---------------- GUI ----------------
class DiagToolApp(tk.Tk):
    def __init__(self):
        super().__init__()
        self.title(APP_TITLE)
        self.configure(bg=BG)
        self.protocol("WM_DELETE_WINDOW", self.on_close)

        # start fullscreen and allow escape to exit fullscreen
        self.attributes("-fullscreen", True)
        self.bind("<Escape>", lambda e: self.attributes("-fullscreen", False))

        # grid: 2 columns - left main column (index 0), right slim column (index 1)
        self.grid_columnconfigure(0, weight=3, uniform="a")
        self.grid_columnconfigure(1, weight=1, uniform="a")
        # rows: system, cpu, gpu, post, footer
        for r in range(6):
            self.grid_rowconfigure(r, weight=0)
        # allow post tile to expand
        self.grid_rowconfigure(3, weight=1)

        # build UI pieces
        self._build_left_tiles()
        self._build_right_tiles()
        self._build_post_tile()
        self._build_footer_buttons()

        # schedule UI update
        self.after(500, self.update_ui)

    def _card_frame(self, parent, row, col, rowspan=1, colspan=1, title="", post_tile=False):
        frame = tk.Frame(parent, bg=CARD_BG, bd=1, relief="flat", highlightbackground=CARD_BORDER, highlightthickness=1)
        frame.grid(row=row, column=col, rowspan=rowspan, columnspan=colspan, sticky="nsew", padx=10, pady=8)
        if title:
            t_color = ACCENT_PURPLE if post_tile else ACCENT_GREEN
            label = tk.Label(frame, text=title, bg=CARD_BG, fg=t_color, font=FONT_TITLE, anchor="w")
            label.pack(fill="x", padx=8, pady=(6,2))
        return frame

    def _build_left_tiles(self):
        # SYSTEM
        self.system_frame = self._card_frame(self, row=0, col=0, title="SYSTEM")
        self.system_text = tk.Label(self.system_frame, text="Loading...", anchor="w", justify="left", bg=CARD_BG, fg=TEXT_MAIN, font=FONT_TEXT)
        self.system_text.pack(fill="both", expand=False, padx=8, pady=6)

        # CPU
        self.cpu_frame = self._card_frame(self, row=1, col=0, title="CPU")
        self.cpu_text = tk.Label(self.cpu_frame, text="Loading...", anchor="w", justify="left", bg=CARD_BG, fg=TEXT_MAIN, font=FONT_TEXT)
        self.cpu_text.pack(fill="both", expand=False, padx=8, pady=6)

        # GPU
        self.gpu_frame = self._card_frame(self, row=2, col=0, title="GPU")
        self.gpu_text = tk.Label(self.gpu_frame, text="Loading...", anchor="w", justify="left", bg=CARD_BG, fg=TEXT_MAIN, font=FONT_TEXT)
        self.gpu_text.pack(fill="both", expand=False, padx=8, pady=6)

    def _build_right_tiles(self):
        # Voltage (slim)
        self.vol_frame = self._card_frame(self, row=0, col=1, title="VOLTAGE")
        self.vol_text = tk.Label(self.vol_frame, text="N/A", anchor="w", justify="left", bg=CARD_BG, fg=TEXT_MAIN, font=FONT_TEXT)
        self.vol_text.pack(fill="both", expand=False, padx=6, pady=6)

        # Network (slim)
        self.net_frame = self._card_frame(self, row=1, col=1, title="NETWORK")
        self.net_text = tk.Label(self.net_frame, text="N/A", anchor="w", justify="left", bg=CARD_BG, fg=TEXT_MAIN, font=FONT_TEXT)
        self.net_text.pack(fill="both", expand=False, padx=6, pady=6)

        # Storage (slim)
        self.storage_frame = self._card_frame(self, row=2, col=1, title="STORAGE")
        self.storage_text = tk.Label(self.storage_frame, text="N/A", anchor="w", justify="left", bg=CARD_BG, fg=TEXT_MAIN, font=FONT_TEXT)
        self.storage_text.pack(fill="both", expand=False, padx=6, pady=6)

    def _build_post_tile(self):
        # POST / Error Log large tile spanning full width bottom
        self.post_frame = self._card_frame(self, row=3, col=0, colspan=2, title="POST / ERROR LOG", post_tile=True)
        # internal text widget with scrollbar
        self.post_text = tk.Text(self.post_frame, height=12, bg="#050505", fg=TEXT_MAIN, insertbackground=TEXT_MAIN, font=("Consolas", 11), wrap="none")
        self.post_text.pack(side="left", fill="both", expand=True, padx=(8,0), pady=8)
        self.post_text.tag_configure("err", foreground=ERROR_RED)
        self.post_text.tag_configure("warn", foreground=ACCENT_BLUE)
        # vertical scrollbar
        vs = tk.Scrollbar(self.post_frame, orient="vertical", command=self.post_text.yview)
        vs.pack(side="right", fill="y", padx=(0,8), pady=8)
        self.post_text['yscrollcommand'] = vs.set

    def _build_footer_buttons(self):
        # button bar (row 4)
        bar = tk.Frame(self, bg=BG)
        bar.grid(row=4, column=0, columnspan=2, sticky="ew", padx=12, pady=(4,12))
        # spacer
        bar.grid_columnconfigure(0, weight=1)
        btnconfig = {"bg": CARD_BG, "fg": ACCENT_GREEN, "bd": 0, "activebackground": "#111111", "font": ("Segoe UI", 10, "bold"), "padx":8, "pady":6}
        # left filler
        tk.Label(bar, text="", bg=BG).grid(row=0, column=0, sticky="w")
        # buttons on right
        bframe = tk.Frame(bar, bg=BG)
        bframe.grid(row=0, column=1, sticky="e")
        # small purple outline for subtle effect on POST-related actions
        def mkbtn(text, cmd):
            btn = tk.Button(bframe, text=text, command=cmd, bg=CARD_BG, fg=ACCENT_GREEN, bd=1, relief="flat", font=("Segoe UI", 10, "bold"), padx=8, pady=6)
            # purple outline subtle for POST actions only
            if text in ("Save Error Report", "Print Error Report"):
                btn.configure(highlightbackground=ACCENT_PURPLE, highlightthickness=1)
            btn.pack(side="left", padx=6)
            return btn
        mkbtn("Save Full Report", self.save_full_report)
        mkbtn("Export Log", self.export_log)
        mkbtn("Save Error Report", self.save_error_report)
        mkbtn("Print Error Report", self.print_error_report)
        # utility small buttons
        tk.Button(bframe, text="Refresh", command=self.manual_refresh, bg=CARD_BG, fg=TEXT_SUB, bd=1, relief="flat", padx=8, pady=6).pack(side="left", padx=6)
        tk.Button(bframe, text="System Report", command=self.system_report_dialog, bg=CARD_BG, fg=TEXT_SUB, bd=1, relief="flat", padx=8, pady=6).pack(side="left", padx=6)
        tk.Button(bframe, text="Exit", command=self.on_close, bg=CARD_BG, fg=ERROR_RED, bd=1, relief="flat", padx=8, pady=6).pack(side="left", padx=6)

    def update_ui(self):
        # pull shared
        with shared_lock:
            snapshot = dict(shared)
        # SYSTEM
        sysd = snapshot.get('system', {})
        sys_lines = []
        sys_lines.append(f"OS: {sysd.get('os','N/A')}")
        sys_lines.append(f"Hostname: {sysd.get('hostname','N/A')}")
        sys_lines.append(f"Kernel: {sysd.get('kernel','N/A')}")
        sys_lines.append(f"Uptime: {sysd.get('uptime','N/A')}")
        sys_lines.append(f"RAM Total: {sysd.get('ram_total','N/A')}")
        sys_lines.append(f"RAM Used: {sysd.get('ram_used','N/A')}")
        self.system_text.config(text="\n".join(sys_lines), justify="left", anchor="w")

        # CPU
        cpud = snapshot.get('cpu', {})
        cpu_lines = []
        cpu_lines.append(f"Model: {cpud.get('model','N/A')}")
        cpu_lines.append(f"Cores: {cpud.get('cores','N/A')}  Threads: {cpud.get('threads','N/A')}")
        cpu_lines.append(f"Clock: {cpud.get('clock','N/A')} (min {cpud.get('min_clock','N/A')} / max {cpud.get('max_clock','N/A')})")
        cpu_lines.append(f"Load: {cpud.get('load','N/A')}")
        cpu_lines.append(f"Temp: {cpud.get('temp_c','N/A')}")
        self.cpu_text.config(text="\n".join(cpu_lines), justify="left", anchor="w")

        # GPU
        gpud = snapshot.get('gpu', {})
        gpu_lines = []
        gpu_lines.append(f"Model: {gpud.get('model','N/A')}")
        gpu_lines.append(f"VRAM: {gpud.get('vram','N/A')}")
        gpu_lines.append(f"Driver: {gpud.get('driver','N/A')}")
        gpu_lines.append(f"Temp: {gpud.get('temp','N/A')}")
        self.gpu_text.config(text="\n".join(gpu_lines), justify="left", anchor="w")

        # Voltage
        vold = snapshot.get('voltage', {})
        vol_lines = []
        vol_lines.append(f"12V: {vold.get('12v','N/A')}")
        vol_lines.append(f"5V: {vold.get('5v','N/A')}")
        vol_lines.append(f"3.3V: {vold.get('3v3','N/A')}")
        vol_lines.append(f"Core: {vold.get('core','N/A')}")
        self.vol_text.config(text="\n".join(vol_lines), justify="left", anchor="w")

        # Network
        netd = snapshot.get('network', {})
        nlines = []
        ifaces = netd.get('ifaces', {}) or {}
        for k,v in ifaces.items():
            ips = ", ".join(v.get('ips', [])) if v.get('ips') else "N/A"
            nlines.append(f"{k}: IPs {ips} MAC {v.get('mac','N/A')} Up {v.get('isup','N/A')} Speed {v.get('speed','N/A')}")
        if not nlines:
            nlines = ["No active interfaces"]
        nlines.append(f"Sent: {netd.get('bytes_sent','N/A')}  Recv: {netd.get('bytes_recv','N/A')}")
        self.net_text.config(text="\n".join(nlines), justify="left", anchor="w")

        # Storage
        stor = snapshot.get('storage', {})
        sd = stor.get('drives', []) or []
        s_lines = []
        for d in sd:
            s_lines.append(f"{d.get('device')} ({d.get('fstype')}) @ {d.get('mountpoint')} - {d.get('total')} used {d.get('used')} ({d.get('percent')})")
        if not s_lines:
            s_lines = ["No drives detected"]
        if stor.get('smart'):
            for st in stor.get('smart', []):
                s_lines.append(f"SMART {st.get('device')}: {st.get('health')}")
        self.storage_text.config(text="\n".join(s_lines), justify="left", anchor="w")

        # POST / Error Log (scrollable)
        post = snapshot.get('post', {})
        history = post.get('history', [])[:1000]
        self.post_text.configure(state="normal")
        self.post_text.delete("1.0", "end")
        if history:
            for line in history:
                tag = None
                if any(k in line.lower() for k in ("error","fail","panic","critical")):
                    tag = "err"
                elif any(k in line.lower() for k in ("warn","deprecated")):
                    tag = "warn"
                if tag:
                    self.post_text.insert("end", line + "\n", tag)
                else:
                    self.post_text.insert("end", line + "\n")
        else:
            # fallback quick system message
            self.post_text.insert("end", "No POST / boot log entries found.\n")
        self.post_text.configure(state="disabled")

        # schedule next update of UI
        self.after(700, self.update_ui)

    # ---------------- Actions ----------------
    def manual_refresh(self):
        # force poll refresh via separate thread that will set shared
        t = threading.Thread(target=_force_poll_once, daemon=True)
        t.start()

    def save_full_report(self):
        ts = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
        path = filedialog.asksaveasfilename(defaultextension=".json", initialfile=f"rebootlab_fullreport_{ts}.json")
        if not path:
            return
        with shared_lock:
            snap = dict(shared)
        try:
            with open(path, "w", encoding="utf-8") as f:
                json.dump(snap, f, indent=2, default=str)
            messagebox.showinfo("Saved", f"Full report saved to:\n{path}")
        except Exception as e:
            messagebox.showerror("Error", f"Save failed: {e}")

    def export_log(self):
        path = filedialog.asksaveasfilename(defaultextension=".log", initialfile=f"rebootlab_log_{datetime.datetime.now().strftime('%Y%m%d_%H%M%S')}.log")
        if not path:
            return
        with shared_lock:
            post = shared.get('post', {})
        try:
            with open(path, "w", encoding="utf-8") as f:
                for l in post.get('history', []):
                    f.write(l + "\n")
            messagebox.showinfo("Exported", f"Log exported to:\n{path}")
        except Exception as e:
            messagebox.showerror("Error", f"Export failed: {e}")

    def save_error_report(self):
        path = filedialog.asksaveasfilename(defaultextension=".txt", initialfile=f"rebootlab_errors_{datetime.datetime.now().strftime('%Y%m%d_%H%M%S')}.txt")
        if not path:
            return
        with shared_lock:
            errors = shared.get('errors', [])
            post = shared.get('post', {})
        try:
            with open(path, "w", encoding="utf-8") as f:
                f.write("POST / Boot Log:\n")
                for l in post.get('history', []):
                    f.write(l + "\n")
                f.write("\nDetected OS Errors:\n")
                for e in errors:
                    f.write(str(e) + "\n")
            messagebox.showinfo("Saved", f"Error report saved to:\n{path}")
        except Exception as e:
            messagebox.showerror("Error", f"Save failed: {e}")

    def print_error_report(self):
        # Write an error report to temp file and attempt to send to 'lp' (Linux) or default print on Windows
        tmp = os.path.join(REPORTS_DIR, f"error_print_{datetime.datetime.now().strftime('%Y%m%d_%H%M%S')}.txt")
        with shared_lock:
            errors = shared.get('errors', [])
            post = shared.get('post', {})
        try:
            with open(tmp, "w", encoding="utf-8") as f:
                f.write("POST / Boot Log:\n")
                for l in post.get('history', []):
                    f.write(l + "\n")
                f.write("\nDetected OS Errors:\n")
                for e in errors:
                    f.write(str(e) + "\n")
            if platform.system() == "Windows":
                os.startfile(tmp, "print")
            else:
                safe_cmd(f"lp {tmp}")
            messagebox.showinfo("Print", "Sent to printer (if configured).")
        except Exception as e:
            messagebox.showerror("Error", f"Print failed: {e}")

    def system_report_dialog(self):
        with shared_lock:
            s = shared.get('system', {})
            last = shared.get('last_update', 'N/A')
        lines = [f"System Report - last update: {last}", ""]
        for k,v in s.items():
            lines.append(f"{k}: {v}")
        messagebox.showinfo("System Report", "\n".join(lines[:300]))

    def on_close(self):
        if messagebox.askokcancel("Exit", "Do you want to quit DiagTool?"):
            stop_event.set()
            self.destroy()

# helper to force one poll on demand
def _force_poll_once():
    try:
        sysd = get_system_info()
        cpud = get_cpu_info()
        gpud = get_gpu_info()
        volt = get_voltage_info()
        netd = get_network_info()
        stor = get_storage_info()
        post = get_post_and_logs()
        errs = scan_os_errors()
        with shared_lock:
            shared['system'] = sysd
            shared['cpu'] = cpud
            shared['gpu'] = gpud
            shared['voltage'] = volt
            shared['network'] = netd
            shared['storage'] = stor
            shared['post'] = post
            shared['errors'] = errs
            shared['last_update'] = datetime.datetime.now().isoformat()
    except Exception:
        pass

# ---------------- Startup ----------------
def main():
    log("Starting ReBoot Lab DiagTool C")
    poll_thread = threading.Thread(target=poll_loop, daemon=True)
    poll_thread.start()
    app = DiagToolApp()
    try:
        app.mainloop()
    except KeyboardInterrupt:
        pass
    finally:
        stop_event.set()
        poll_thread.join(timeout=2)
        log("DiagTool stopped")

if __name__ == "__main__":
    main()
